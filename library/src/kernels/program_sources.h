// This file is auto-generated. Do not edit!
// File contains kernel sources generated from *.cl files.
// Sources have the same name as the cl files.
// Each source code have it's own key created as <filename>_key
// In the code they will build a map {source_key : kernel_source }

#ifndef _PROGRAM_SOURCES_H_
#define _PROGRAM_SOURCES_H_

#ifdef __cplusplus
extern "C" {
#endif

const char* csrmv_beta0_key="csrmv_beta0";
const char* csrmv_beta0="#ifndef INDEX_TYPE\n"
"#error INDEX_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef VALUE_TYPE\n"
"#error VALUE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef SIZE_TYPE\n"
"#error SIZE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef WG_SIZE\n"
"#error WG_SIZE undefined!\n"
"#endif\n"
"\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 64\n"
"#endif\n"
"\n"
"#ifndef SUBWAVE_SIZE\n"
"#define SUBWAVE_SIZE WAVE_SIZE\n"
"#endif\n"
"\n"
"#if ( (SUBWAVE_SIZE > WAVE_SIZE) || (SUBWAVE_SIZE != 2 && SUBWAVE_SIZE != 4 && SUBWAVE_SIZE != 8 && SUBWAVE_SIZE != 16 && SUBWAVE_SIZE != 32 && SUBWAVE_SIZE != 64) )\n"
"# error SUBWAVE_SIZE is not  a power of two!\n"
"#endif\n"
"\n"
"// Uses macro constants:\n"
"// WAVE_SIZE  - \"warp size\", typically 64 (AMD) or 32 (NV)\n"
"// WG_SIZE    - workgroup (\"block\") size, 1D representation assumed\n"
"// INDEX_TYPE - typename for the type of integer data read by the kernel,  usually unsigned int\n"
"// VALUE_TYPE - typename for the type of floating point data, usually double\n"
"// SUBWAVE_SIZE - the length of a \"sub-wave\", a power of 2, i.e. 1,2,4,...,WAVE_SIZE, assigned to process a single matrix row\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void csrmv_beta0 (     const INDEX_TYPE num_rows,\n"
"                __global const VALUE_TYPE * const alpha,\n"
"                __global const INDEX_TYPE * const row_offset,\n"
"                __global const INDEX_TYPE * const col,\n"
"                __global const VALUE_TYPE * const val,\n"
"                __global const VALUE_TYPE * const x,\n"
"                __global       VALUE_TYPE * y)\n"
"{\n"
"    local volatile VALUE_TYPE sdata [WG_SIZE + SUBWAVE_SIZE / 2];\n"
"\n"
"    //const int vectors_per_block = WG_SIZE/SUBWAVE_SIZE;\n"
"    const int global_id   = get_global_id(0);         // global workitem id\n"
"    const int local_id    = get_local_id(0);          // local workitem id\n"
"    const int thread_lane = local_id & (SUBWAVE_SIZE - 1);\n"
"    const int vector_id   = global_id / SUBWAVE_SIZE; // global vector id\n"
"    //const int vector_lane = local_id / SUBWAVE_SIZE;  // vector id within the workgroup\n"
"    const int num_vectors = get_global_size(0) / SUBWAVE_SIZE;\n"
"\n"
"    const VALUE_TYPE _alpha = alpha[0];\n"
"\n"
"    for(INDEX_TYPE row = vector_id; row < num_rows; row += num_vectors)\n"
"    {\n"
"        const int row_start = row_offset[row];\n"
"        const int row_end   = row_offset[row+1];\n"
"        VALUE_TYPE sum = (VALUE_TYPE) 0;\n"
"\n"
"        for(int j = row_start + thread_lane; j < row_end; j += SUBWAVE_SIZE)\n"
"            sum = fma( _alpha * val[j], x[col[j]], sum);//sum += val[j] * x[col[j]];\n"
"\n"
"        //parllel reduction in shared memory\n"
"        sdata[local_id] = sum;\n"
"        if (SUBWAVE_SIZE > 32) sdata[local_id] = sum += sdata[local_id + 32];\n"
"        if (SUBWAVE_SIZE > 16) sdata[local_id] = sum += sdata[local_id + 16];\n"
"        if (SUBWAVE_SIZE > 8)  sdata[local_id] = sum += sdata[local_id + 8];\n"
"        if (SUBWAVE_SIZE > 4)  sdata[local_id] = sum += sdata[local_id + 4];\n"
"        if (SUBWAVE_SIZE > 2)  sdata[local_id] = sum += sdata[local_id + 2];\n"
"        if (SUBWAVE_SIZE > 1)                    sum += sdata[local_id + 1];\n"
"\n"
"        if (thread_lane == 0)\n"
"            y[row] = sum;\n"
"    }\n"
"}\n"
"\n"
;
const char* csrmv_general_key="csrmv_general";
const char* csrmv_general="#ifndef INDEX_TYPE\n"
"#error INDEX_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef VALUE_TYPE\n"
"#error VALUE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef SIZE_TYPE\n"
"#error SIZE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef WG_SIZE\n"
"#error WG_SIZE undefined!\n"
"#endif\n"
"\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 64\n"
"#endif\n"
"\n"
"#ifndef SUBWAVE_SIZE\n"
"#define SUBWAVE_SIZE WAVE_SIZE\n"
"#endif\n"
"\n"
"#if ( (SUBWAVE_SIZE > WAVE_SIZE) || (SUBWAVE_SIZE != 2 && SUBWAVE_SIZE != 4 && SUBWAVE_SIZE != 8 && SUBWAVE_SIZE != 16 && SUBWAVE_SIZE != 32 && SUBWAVE_SIZE != 64) )\n"
"# error SUBWAVE_SIZE is not  a power of two!\n"
"#endif\n"
"\n"
"// Uses macro constants:\n"
"// WAVE_SIZE  - \"warp size\", typically 64 (AMD) or 32 (NV)\n"
"// WG_SIZE    - workgroup (\"block\") size, 1D representation assumed\n"
"// INDEX_TYPE - typename for the type of integer data read by the kernel,  usually unsigned int\n"
"// VALUE_TYPE - typename for the type of floating point data, usually double\n"
"// SUBWAVE_SIZE - the length of a \"sub-wave\", a power of 2, i.e. 1,2,4,...,WAVE_SIZE, assigned to process a single matrix row\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void csrmv_general (     const INDEX_TYPE num_rows,\n"
"                __global const VALUE_TYPE * const alpha,\n"
"                __global const INDEX_TYPE * const row_offset,\n"
"                __global const INDEX_TYPE * const col,\n"
"                __global const VALUE_TYPE * const val,\n"
"                __global const VALUE_TYPE * const x,\n"
"                __global const VALUE_TYPE * const beta,\n"
"                __global       VALUE_TYPE * y)\n"
"{\n"
"    local volatile VALUE_TYPE sdata [WG_SIZE + SUBWAVE_SIZE / 2];\n"
"\n"
"    //const int vectors_per_block = WG_SIZE/SUBWAVE_SIZE;\n"
"    const int global_id   = get_global_id(0);         // global workitem id\n"
"    const int local_id    = get_local_id(0);          // local workitem id\n"
"    const int thread_lane = local_id & (SUBWAVE_SIZE - 1);\n"
"    const int vector_id   = global_id / SUBWAVE_SIZE; // global vector id\n"
"    //const int vector_lane = local_id / SUBWAVE_SIZE;  // vector id within the workgroup\n"
"    const int num_vectors = get_global_size(0) / SUBWAVE_SIZE;\n"
"\n"
"    const VALUE_TYPE _alpha = alpha[0];\n"
"    const VALUE_TYPE _beta = beta[0];\n"
"\n"
"    for(INDEX_TYPE row = vector_id; row < num_rows; row += num_vectors)\n"
"    {\n"
"        const int row_start = row_offset[row];\n"
"        const int row_end   = row_offset[row+1];\n"
"        VALUE_TYPE sum = (VALUE_TYPE) 0;\n"
"\n"
"        for(int j = row_start + thread_lane; j < row_end; j += SUBWAVE_SIZE)\n"
"        {\n"
"\n"
"            sum = fma(_alpha * val[j], x[col[j]], sum);//sum += val[j] * x[col[j]];\n"
"        }\n"
"\n"
"        //parllel reduction in shared memory\n"
"        sdata[local_id] = sum;\n"
"        if (SUBWAVE_SIZE > 32) sdata[local_id] = sum += sdata[local_id + 32];\n"
"        if (SUBWAVE_SIZE > 16) sdata[local_id] = sum += sdata[local_id + 16];\n"
"        if (SUBWAVE_SIZE > 8)  sdata[local_id] = sum += sdata[local_id + 8];\n"
"        if (SUBWAVE_SIZE > 4)  sdata[local_id] = sum += sdata[local_id + 4];\n"
"        if (SUBWAVE_SIZE > 2)  sdata[local_id] = sum += sdata[local_id + 2];\n"
"        if (SUBWAVE_SIZE > 1)                    sum += sdata[local_id + 1];\n"
"\n"
"        if (thread_lane == 0)\n"
"            y[row] = sum + _beta * y[row];\n"
"    }\n"
"}\n"
"\n"
;
const char* csrmv_alpha1_key="csrmv_alpha1";
const char* csrmv_alpha1="#ifndef INDEX_TYPE\n"
"#error INDEX_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef VALUE_TYPE\n"
"#error VALUE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef SIZE_TYPE\n"
"#error SIZE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef WG_SIZE\n"
"#error WG_SIZE undefined!\n"
"#endif\n"
"\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 64\n"
"#endif\n"
"\n"
"#ifndef SUBWAVE_SIZE\n"
"#define SUBWAVE_SIZE WAVE_SIZE\n"
"#endif\n"
"\n"
"#if ( (SUBWAVE_SIZE > WAVE_SIZE) || (SUBWAVE_SIZE != 2 && SUBWAVE_SIZE != 4 && SUBWAVE_SIZE != 8 && SUBWAVE_SIZE != 16 && SUBWAVE_SIZE != 32 && SUBWAVE_SIZE != 64) )\n"
"# error SUBWAVE_SIZE is not  a power of two!\n"
"#endif\n"
"\n"
"// Uses macro constants:\n"
"// WAVE_SIZE  - \"warp size\", typically 64 (AMD) or 32 (NV)\n"
"// WG_SIZE    - workgroup (\"block\") size, 1D representation assumed\n"
"// INDEX_TYPE - typename for the type of integer data read by the kernel,  usually unsigned int\n"
"// VALUE_TYPE - typename for the type of floating point data, usually double\n"
"// SUBWAVE_SIZE - the length of a \"sub-wave\", a power of 2, i.e. 1,2,4,...,WAVE_SIZE, assigned to process a single matrix row\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void csrmv_alpha1 (     const INDEX_TYPE num_rows,\n"
"                __global const INDEX_TYPE * const row_offset,\n"
"                __global const INDEX_TYPE * const col,\n"
"                __global const VALUE_TYPE * const val,\n"
"                __global const VALUE_TYPE * const x,\n"
"                __global const VALUE_TYPE * const beta,\n"
"                __global       VALUE_TYPE * y)\n"
"{\n"
"    local volatile VALUE_TYPE sdata [WG_SIZE + SUBWAVE_SIZE / 2];\n"
"\n"
"    //const int vectors_per_block = WG_SIZE/SUBWAVE_SIZE;\n"
"    const int global_id   = get_global_id(0);         // global workitem id\n"
"    const int local_id    = get_local_id(0);          // local workitem id\n"
"    const int thread_lane = local_id & (SUBWAVE_SIZE - 1);\n"
"    const int vector_id   = global_id / SUBWAVE_SIZE; // global vector id\n"
"    //const int vector_lane = local_id / SUBWAVE_SIZE;  // vector id within the workgroup\n"
"    const int num_vectors = get_global_size(0) / SUBWAVE_SIZE;\n"
"\n"
"    const VALUE_TYPE _beta = beta[0];\n"
"\n"
"    for(INDEX_TYPE row = vector_id; row < num_rows; row += num_vectors)\n"
"    {\n"
"        const int row_start = row_offset[row];\n"
"        const int row_end   = row_offset[row+1];\n"
"        VALUE_TYPE sum = (VALUE_TYPE) 0;\n"
"\n"
"        for(int j = row_start + thread_lane; j < row_end; j += SUBWAVE_SIZE)\n"
"            sum = fma(val[j], x[col[j]], sum);//sum += val[j] * x[col[j]];\n"
"\n"
"        //parllel reduction in shared memory\n"
"        sdata[local_id] = sum;\n"
"        if (SUBWAVE_SIZE > 32) sdata[local_id] = sum += sdata[local_id + 32];\n"
"        if (SUBWAVE_SIZE > 16) sdata[local_id] = sum += sdata[local_id + 16];\n"
"        if (SUBWAVE_SIZE > 8)  sdata[local_id] = sum += sdata[local_id + 8];\n"
"        if (SUBWAVE_SIZE > 4)  sdata[local_id] = sum += sdata[local_id + 4];\n"
"        if (SUBWAVE_SIZE > 2)  sdata[local_id] = sum += sdata[local_id + 2];\n"
"        if (SUBWAVE_SIZE > 1)                    sum += sdata[local_id + 1];\n"
"\n"
"        if (thread_lane == 0)\n"
"            y[row] = sum + _beta * y[row];\n"
"    }\n"
"}\n"
"\n"
;
const char* scale_key="scale";
const char* scale="//TEST KERNEL\n"
"\n"
"#ifndef INDEX_TYPE\n"
"#error INDEX_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef VALUE_TYPE\n"
"#error VALUE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef SIZE_TYPE\n"
"#error SIZE_TYPE undefined!\n"
"#endif\n"
"\n"
"// v = v*alpha\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE, 1, 1)))\n"
"void scale ( __global VALUE_TYPE* v,\n"
"             __global VALUE_TYPE* alpha,\n"
"             const SIZE_TYPE size)\n"
"{\n"
"    const int i = get_global_id(0);\n"
"\n"
"    if (i >= size) return;\n"
"\n"
"    v[i] = v[i]* alpha[0];\n"
"}\n"
"\n"
;
const char* csrmv_alpha1_beta0_key="csrmv_alpha1_beta0";
const char* csrmv_alpha1_beta0="#ifndef INDEX_TYPE\n"
"#error INDEX_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef VALUE_TYPE\n"
"#error VALUE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef SIZE_TYPE\n"
"#error SIZE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef WG_SIZE\n"
"#error WG_SIZE undefined!\n"
"#endif\n"
"\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 64\n"
"#endif\n"
"\n"
"#ifndef SUBWAVE_SIZE\n"
"#define SUBWAVE_SIZE WAVE_SIZE\n"
"#endif\n"
"\n"
"#if ( (SUBWAVE_SIZE > WAVE_SIZE) || (SUBWAVE_SIZE != 2 && SUBWAVE_SIZE != 4 && SUBWAVE_SIZE != 8 && SUBWAVE_SIZE != 16 && SUBWAVE_SIZE != 32 && SUBWAVE_SIZE != 64) )\n"
"# error SUBWAVE_SIZE is not  a power of two!\n"
"#endif\n"
"\n"
"// Uses macro constants:\n"
"// WAVE_SIZE  - \"warp size\", typically 64 (AMD) or 32 (NV)\n"
"// WG_SIZE    - workgroup (\"block\") size, 1D representation assumed\n"
"// INDEX_TYPE - typename for the type of integer data read by the kernel,  usually unsigned int\n"
"// VALUE_TYPE - typename for the type of floating point data, usually double\n"
"// SUBWAVE_SIZE - the length of a \"sub-wave\", a power of 2, i.e. 1,2,4,...,WAVE_SIZE, assigned to process a single matrix row\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void csrmv_alpha1_beta0 (     const INDEX_TYPE num_rows,\n"
"                __global const INDEX_TYPE * const row_offset,\n"
"                __global const INDEX_TYPE * const col,\n"
"                __global const VALUE_TYPE * const val,\n"
"                __global const VALUE_TYPE * const x,\n"
"                __global       VALUE_TYPE * y)\n"
"{\n"
"    local volatile VALUE_TYPE sdata [WG_SIZE + SUBWAVE_SIZE / 2];\n"
"\n"
"    //const int vectors_per_block = WG_SIZE/SUBWAVE_SIZE;\n"
"    const int global_id   = get_global_id(0);         // global workitem id\n"
"    const int local_id    = get_local_id(0);          // local workitem id\n"
"    const int thread_lane = local_id & (SUBWAVE_SIZE - 1);\n"
"    const int vector_id   = global_id / SUBWAVE_SIZE; // global vector id\n"
"    //const int vector_lane = local_id / SUBWAVE_SIZE;  // vector id within the workgroup\n"
"    const int num_vectors = get_global_size(0) / SUBWAVE_SIZE;\n"
"\n"
"    for(INDEX_TYPE row = vector_id; row < num_rows; row += num_vectors)\n"
"    {\n"
"        const int row_start = row_offset[row];\n"
"        const int row_end   = row_offset[row+1];\n"
"        VALUE_TYPE sum = (VALUE_TYPE) 0;\n"
"\n"
"        for(int j = row_start + thread_lane; j < row_end; j += SUBWAVE_SIZE)\n"
"            sum = fma(val[j], x[col[j]], sum);//sum += val[j] * x[col[j]];\n"
"\n"
"        //parllel reduction in shared memory\n"
"        sdata[local_id] = sum;\n"
"        if (SUBWAVE_SIZE > 32) sdata[local_id] = sum += sdata[local_id + 32];\n"
"        if (SUBWAVE_SIZE > 16) sdata[local_id] = sum += sdata[local_id + 16];\n"
"        if (SUBWAVE_SIZE > 8)  sdata[local_id] = sum += sdata[local_id + 8];\n"
"        if (SUBWAVE_SIZE > 4)  sdata[local_id] = sum += sdata[local_id + 4];\n"
"        if (SUBWAVE_SIZE > 2)  sdata[local_id] = sum += sdata[local_id + 2];\n"
"        if (SUBWAVE_SIZE > 1)                    sum += sdata[local_id + 1];\n"
"\n"
"        if (thread_lane == 0)\n"
"            y[row] = sum;\n"
"    }\n"
"}\n"
"\n"
;
const char* csrmv_beta1_key="csrmv_beta1";
const char* csrmv_beta1="#ifndef INDEX_TYPE\n"
"#error INDEX_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef VALUE_TYPE\n"
"#error VALUE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef SIZE_TYPE\n"
"#error SIZE_TYPE undefined!\n"
"#endif\n"
"\n"
"#ifndef WG_SIZE\n"
"#error WG_SIZE undefined!\n"
"#endif\n"
"\n"
"#ifndef WAVE_SIZE\n"
"#define WAVE_SIZE 64\n"
"#endif\n"
"\n"
"#ifndef SUBWAVE_SIZE\n"
"#define SUBWAVE_SIZE WAVE_SIZE\n"
"#endif\n"
"\n"
"#if ( (SUBWAVE_SIZE > WAVE_SIZE) || (SUBWAVE_SIZE != 2 && SUBWAVE_SIZE != 4 && SUBWAVE_SIZE != 8 && SUBWAVE_SIZE != 16 && SUBWAVE_SIZE != 32 && SUBWAVE_SIZE != 64) )\n"
"# error SUBWAVE_SIZE is not  a power of two!\n"
"#endif\n"
"\n"
"// Uses macro constants:\n"
"// WAVE_SIZE  - \"warp size\", typically 64 (AMD) or 32 (NV)\n"
"// WG_SIZE    - workgroup (\"block\") size, 1D representation assumed\n"
"// INDEX_TYPE - typename for the type of integer data read by the kernel,  usually unsigned int\n"
"// VALUE_TYPE - typename for the type of floating point data, usually double\n"
"// SUBWAVE_SIZE - the length of a \"sub-wave\", a power of 2, i.e. 1,2,4,...,WAVE_SIZE, assigned to process a single matrix row\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void csrmv_beta1 (     const INDEX_TYPE num_rows,\n"
"                __global const VALUE_TYPE * const alpha,\n"
"                __global const INDEX_TYPE * const row_offset,\n"
"                __global const INDEX_TYPE * const col,\n"
"                __global const VALUE_TYPE * const val,\n"
"                __global const VALUE_TYPE * const x,\n"
"                __global       VALUE_TYPE * y)\n"
"{\n"
"    local volatile VALUE_TYPE sdata [WG_SIZE + SUBWAVE_SIZE / 2];\n"
"\n"
"    //const int vectors_per_block = WG_SIZE/SUBWAVE_SIZE;\n"
"    const int global_id   = get_global_id(0);         // global workitem id\n"
"    const int local_id    = get_local_id(0);          // local workitem id\n"
"    const int thread_lane = local_id & (SUBWAVE_SIZE - 1);\n"
"    const int vector_id   = global_id / SUBWAVE_SIZE; // global vector id\n"
"    //const int vector_lane = local_id / SUBWAVE_SIZE;  // vector id within the workgroup\n"
"    const int num_vectors = get_global_size(0) / SUBWAVE_SIZE;\n"
"\n"
"    const VALUE_TYPE _alpha = alpha[0];\n"
"\n"
"    for(INDEX_TYPE row = vector_id; row < num_rows; row += num_vectors)\n"
"    {\n"
"        const int row_start = row_offset[row];\n"
"        const int row_end   = row_offset[row+1];\n"
"        VALUE_TYPE sum = (VALUE_TYPE) 0;\n"
"\n"
"        for(int j = row_start + thread_lane; j < row_end; j += SUBWAVE_SIZE)\n"
"            sum = fma( _alpha * val[j], x[col[j]], sum);//sum += val[j] * x[col[j]];\n"
"\n"
"        //parllel reduction in shared memory\n"
"        sdata[local_id] = sum;\n"
"        if (SUBWAVE_SIZE > 32) sdata[local_id] = sum += sdata[local_id + 32];\n"
"        if (SUBWAVE_SIZE > 16) sdata[local_id] = sum += sdata[local_id + 16];\n"
"        if (SUBWAVE_SIZE > 8)  sdata[local_id] = sum += sdata[local_id + 8];\n"
"        if (SUBWAVE_SIZE > 4)  sdata[local_id] = sum += sdata[local_id + 4];\n"
"        if (SUBWAVE_SIZE > 2)  sdata[local_id] = sum += sdata[local_id + 2];\n"
"        if (SUBWAVE_SIZE > 1)                    sum += sdata[local_id + 1];\n"
"\n"
"        if (thread_lane == 0)\n"
"            y[row] = sum + y[row];\n"
"    }\n"
"}\n"
"\n"
;


#ifdef __cplusplus
}
#endif
#endif //_PROGRAM_SOURCES_H
